Exception//例外


<プログラムの構成によって回避可能な例外の一例>

ArrayIndexOutBoundsException//指定した添え字が範囲外。
//対策:配列内の動きに収める。
NullPointerException//変数にnullが入っている場合に発生する。
//対策:
//プログラム上、インスタンス生成と代入が正しく行われているかチェックする。
//プログラムで変数のnullチェックを行い、エラーの発生を回避する。
NumberFormatException//文字列の値を数値にキャストしようとしたが、文字列に数値として正しくない値が設定されている場合に発生する。
//対策:
//引数に英字や記号など、数値以外の文字が設定されていないかチェックする。
//文字列が空白文字「""」でないかチェックする。
//数値型で扱える値の範囲をオーバーしていないかチェックする。


<例外の送信>
//throwキーワードをメソッドのブロック内で利用することにより、システム的に不都合が出る場合に意図的に例外を発生させることができる。
throw new 例外クラス(引数);//引数で表示するメッセージを指定できる。
//if文で条件をつけることが多い。


<例外処理>
//処理に発生した例外によってその後の処理を行う仕組み
try { //例外が起こりうる処理を記述する
    //処理
} catch (例外クラス1 | 例外クラス2 変数名) { //例外発生時の処理を記述する。
//発生しうる例外ごとに複数のブロックを作成可能。変数名にはよく e が用いられる。パイプ以降は省略可。
    //処理
} finally { //try-catchのブロックが終了した後に最終的に行いたい処理を記述する。
    //最終的に実行したい処理があれば記述(省略可)
}
複数のキャッチブロックを扱う上での注意点
//catch(例外のスーパークラス 変数名) にすることで、サブクラスの例外を全て補足できる。
//しかし、サブクラスを実行する前にスーパークラスでコンパイルエラーとなるため、サブクラスの処理が実行されず原因を特定できない。
//そのため、例外クラスでスーパークラスを指定する際は、最後のcatchブロックに付け加えるようにする。
//また、スーパークラスとサブクラス同時には補足できないため、その場合は｜を使用せずに分ける。

<メッセージの表示>
throw new 例外名();//引数に表示させたいメッセージを記入することもできる。

<メッセージの受け取り>
getMessage()
//例文）
//System.out.print(e.getMessage()); catch処理内

<例外の送信>
//メソッドを呼び出したメソッドに例外処理を委ねる。
//try-catchは処理するメソッド内で行う。
//例外を受け取ったメソッドでthrowsを指示することもできる。
public 返り値 関数名() throws 例外クラス {
    //処理
}
//例）
public static void main(String[] args) {
    try {
        method1();
    } catch (NumberFormatException e) {
        e.printStackTrace();//どこでどんな例外が発生したのかをまとめたメソッド
    }
}
//NumberFormatExceptionが発生した場合、呼び出し元に例外処理を任せる。
public static int method1() throws NumberFormatException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int ret = 0;
    try {
        String line = br.readLine();
        //lineの値によってはint型に変換できず例外発生。
        ret = Integer.parseInt(line);
    } catch(IOException e) {
        e.printStackTrace();
    }
    return ret;
}

<複数の例外の送信>
//throwsキーワードに続いてカンマ区切りで例外クラスを指定できる。
//例）
public static void method2() throws IOException, SQLException {
    //処理
}

<実務での例外処理>
//処理が複雑で大きいシステムの場合は、上位の呼び出し元でまとめて処理する。よって可読性、保守性が高まる。
//また例外が発生しうるメソッド側ではどのように対処すべきか判断できない場合がほとんどなので、基本的にはthrowsを使って呼び出し元に送信する。

<例外のラッピング>
//呼び出し元で新たに例外を発生させること。

<例外チェーン>
//例外のラッピングをした際に、大元の原因の特定がしづらくなってしまう。
throw new ServiceException("(メッセージ)"、e);//ラッピング
//第二引数に本来の例外クラスのインスタンスを渡すことで、原因となった例外に含まれる情報も併せて表示する。

<チェック例外>
//実行時に不都合が発生しうるために例外処理を記述したかコンパイル時にチェックされる例外。
//例外処理または例外の送信の記述をしないとコンパイルエラーとなる。
//代表的なチェック例外
//IOException...入出力に関する例外。
//FileNotException...ファイルへのアクセスで発生する例外。
//ClassNotFoundException...存在しないクラスのインスタンスを生成しようとすると発生する例外。
