インスタンス生成 //オブジェクトともいう
型 変数名 = new クラス名(); //型は参照型 見分けがつくようにクラス名を使う

フィールドへのアクセス
参照型変数.フィールド名; //参照する数だけ.で繋ぐ

メソッドの定義
//インスタンスメソッドとクラスメソッドの二種類ある
//インスタンスメソッド...インスタンスごとに値を保持する
//クラスメソッド...インスタンス関わらずクラス自身が保持する
public 型 メソッド名(引数) {
    //処理
}

メソッドの呼び出し
//インスタンス生成
変数名.メソッド名();

this //参照型変数の代わりに用いられる 呼び出し元のオブジェクトを参照する
this.フィールド名 = 値; //代入
または、
this.メソッド名(); //呼び出し

コンストラクタ //インスタンス生成時に一度だけ呼び出される
public クラス名(引数) { //インスタンス生成時に任意の引数を渡すことで、オーバーロードしているコンストラクタへもアクセスできる
    //処理
}

コンストラクタからコンストラクタを呼び出す
this(引数); //任意の引数を渡すことで、オーバーロードしているコンストラクタへもアクセスできる

継承 //スーパークラスからサブクラスに、機能を引き継ぐ
class サブクラス名 extends スーパークラス名 {
    //フィールド
    //メソッド
}

オーバーライド //スーパークラスから引き継いだメソッドを上書きする
@Override //メソッド名と同名のスーパークラスが無ければコンパイルエラーとなる
public 型 メソッド名(引数) {
    //処理
}

定数の再代入の禁止 //再代入を許可しないフィールドをオブジェクト定数という
public final 型 オブジェクト定数名 = 値; //スーパークラスにて オブジェクト定数の定義  オブジェクト定数は大文字で書き、_で繋ぐ
this.オブジェクト定数名; //サブクラスにて 呼び出し
または、
参照型変数.オブジェクト定数名;

メソッドのオーバーライドの禁止
final public 型 メソッド(引数) { //スーパークラスにて
    //処理
}

クラスの継承の禁止
final class クラス名 {
    //フィールド
    //メソッド
}

スーパークラスのメソッドを利用する
super.メソッド名(引数); //スーパークラスを継承しているサブクラス内で使用可能
//オーバーロードしているメソッドを呼び出す場合、優先度は@Override > superとなる

スーパークラスのコンストラクタを呼び出す
super(引数); //コンストラクタ内の先頭にて
//コンストラクタの先頭では暗黙的にsuper()が実行されている
//this()を利用すると、そのコンストラクタではsuper()が呼び出せない

アクセス修飾子 class クラス名
アクセス修飾子 メソッド名()
//１つのファイルにつき、１つのpublicクラス
public
//アクセス可能範囲＝どこからでも
protected
//アクセス可能範囲＝クラス内、継承を利用したサブクラスのメソッド、同一パッケージのクラスで定義した参照型の変数から
なし
//アクセス修飾子なしの場合、同一パッケージ内のクラスからのみアクセス可能
private
//アクセス可能範囲＝クラス内から

パッケージ化の宣言
package パッケージ名;
//クラスと同名のフォルダに入れる

インポート
import 完全修飾名(パッケージ名.クラス名);
//もしくは、
import パッケージ名.* //利用するパッケージの中のクラスを読み込む


カプセル化
//オブジェクト内にフィールドとメソッドをまとめておき、フィールドへのアクセスをメソッドを介してのみ許可することで、データの隠蔽性を高めるための手法
setフィールド名(引数)//setter
//値を渡す
getフィールド名(引数)//getter
//値を受け取る


static修飾子
//静的メンバとして扱うこと（静的メンバ = インスタンス生成の要否を問わず、クラスで共通で管理するフィールドやメソッド）
//クラス変数、クラスメソッドはインスタンス変数、インスタンスメソッドにアクセスできない
クラス変数名の定義
アクセス修飾子 static 型 フィールド名;
//クラスメソッドも同様
クラス変数へのアクセス
クラス変数名//thisは利用しない
//クラスメソッドも同様
クラス外からのクラス変数へのアクセス
クラス名.クラス変数名
//クラスメソッドも同様

void
//戻り値の型
//値を返さないメソッドとして定義される
//returnで戻り値を返そうとするとエラーになる

抽象クラス
//継承しなければならない
//インスタンス化は不可
//1.機能追加...スーパークラスが軸
//2.機能集約...サブクラスが軸
abstract class クラス名 {
    //フィールド、メソッドなど
}
//extendsで抽象クラスを継承できる

抽象メソッドの定義
//抽象メソッドの処理の中身はサブクラスが決めるため定義しない
//オーバーライドが前提となるため、アクセス修飾子にはprivate以外を設定する
アクセス修飾子 abstract [static] 型 メソッド名([引数]);

抽象メソッドの実装
//中身の無い抽象メソッドをサブクラスで具体的に定義すること
//メソッド名、返り値の型、引数を抽象クラスのものと統一する
//アクセス修飾子は抽象メソッドと同じか、より緩いものにする

インターフェース(抽象型)
//抽象メソッドと定数のみ定義可能
interface インターフェース名 {
    //定数、抽象メソッド
}

インターフェースの変数の定義
//1,すべての変数は public static final が付いている定義と同じになる
//2,public,static,final修飾子のいずれか、もしくは全ての省略が可能
//3,定数となるため初期値の設定が必要となる

インターフェースのメソッドの定義
//1,全てのメソッドはpublic abstractが付いている定義と同じになる
//2,public,abstract修飾子のいずれかが、もしくは全ての省略が可能

実装クラス
//インターフェースを実装するクラス
class クラス名 implements インターフェース名 {
    //フィールド、メソッド
}

ポリモーフィズム(多様性)
//同じメソッドをクラスによって使い分けること
//メソッドの引数にはクラス名、インターフェイス名、抽象クラス名を指定することが可能
アクセス修飾子 [static] 型 メソッド名(クラス名 引数名) {
    //処理
}
